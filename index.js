const{Mutex:Mutex}=require("async-mutex"),roomMutex=new Mutex,express=require("express"),mongoose=require("mongoose"),bodyParser=require("body-parser"),moment=require("moment-timezone"),cors=require("cors"),WebSocket=require("ws"),http=require("http"),app=express(),PORT=process.env.PORT||3e3;app.use(cors({origin:!0,credentials:!0})),app.use(bodyParser.json());const{mongoUrl:mongoUrl}=require("./dbConnection"),RoomModel=require("./models/roomsdata"),Message=require("./models/message"),badgeModel=require("./models/badges"),ColorsModel=require("./models/colors"),User=require("./models/user"),Offer=require("./models/offermodal"),Mods=require("./models/mods"),Banned=require("./models/banned"),PersonalMessage=require("./models/personalmessage"),userRoutes=require("./routes/userRoutes"),{connect:connect}=require("./models/user"),Notification=require("./models/notifications"),CoordinateModel=require("./models/coordinates"),PackageModel=require("./models/vip");Otp=require("./models/otp"),TransactionModel=require("./models/transactions"),PaymentDetailsModel=require("./models/PaymentDetails.Js"),ShopDetails=require("./models/shopdetails"),server=http.createServer(app);var nodemailer=require("nodemailer");const bcrypt=require("bcrypt");async function deleteCoordinates(e){const s=await mongoose.startSession();s.startTransaction();try{const o=await RoomModel.find({coordinates:{$elemMatch:{email:e}}}).session(s);for(const s of o)s.coordinates=s.coordinates.filter((s=>s.email!==e)),await s.save();await s.commitTransaction(),s.endSession()}catch(e){await s.abortTransaction(),s.endSession(),console.error(e)}}async function mergedates(e,s){const o=moment().tz("Asia/Karachi"),t=await ShopDetails.find({purchasedBy:e,itemId:s});var a=[];for(const e of t)a.push(e.validtill);await ShopDetails.deleteMany({_id:{$in:t.map((e=>e._id))}});const r=a.filter((e=>moment.tz(e,"Asia/Karachi").isSameOrAfter(o)));if(r.length>0){const t=r.reduce(((e,s)=>e+moment.tz(s,"Asia/Karachi").diff(o,"days")),0),a=o.add(t,"days"),n=a.format("YYYY-MM-DD HH:mm:ss"),i=a.format("DD-MM-YYYY");console.log(n);const c={itemId:s,purchasedBy:e,purchaseDate:moment().tz("Asia/Karachi").format("YYYY-MM-DD HH:mm:ss"),validtill:n},d=new ShopDetails(c);return await d.save(),i}return 0}async function deleteMessages(e){try{const s=await Message.find({messages:{$elemMatch:{user_id:e}}});if(!(s&&s.length>0))return 2;for(const o of s)return o.messages=o.messages.filter((s=>s.user_id!==e)),await o.save(),1}catch(e){return console.log("ERR"+e),0}}function genotp(){return Math.floor(9e4*Math.random())+1e4}function sendotp(e,s){try{Otp.deleteMany({user:e}).then((o=>{new Otp({user:e,code:s}).save().then((()=>{})).catch((e=>{console.error(e)}))})).catch((e=>{console.error(e)}));var o=nodemailer.createTransport({service:"gmail",auth:{user:"Info.chatzyr@gmail.com",pass:"haan rydj ivyx adcr"}}),t={from:"Info.chatzyr@gmail.com",to:e,subject:"üîê Verify Your Email for OTP",html:`\n            <html>\n                <head>\n                    <style>\n                        body {\n                            font-family: Arial, sans-serif;\n                            background-color: #f2f2f2;\n                        }\n                        .container {\n                            max-width: 600px;\n                            margin: 0 auto;\n                            padding: 20px;\n                            background-color: #ffffff;\n                            border-radius: 8px;\n                        }\n                        h1 {\n                            color: #007BFF;\n                            text-align: center;\n                        }\n                        p {\n                            color: #333;\n                            font-size: 16px;\n                            text-align: center;\n                        }\n                        .otp {\n                            font-size: 24px;\n                            font-weight: bold;\n                            color: #FF5733;\n                            text-align: center;\n                            margin-top: 20px;\n                        }\n                    </style>\n                </head>\n                <body>\n                    <div class="container">\n                        <h1>üîê Verify Your Email for ChatZyr </h1>\n                        <p>Hi there! Please verify your email to complete the OTP verification process.</p>\n                        <p>Your OTP: <span class="otp">${s}</span></p>\n                    </div>\n                </body>\n            </html>\n        `};return o.sendMail(t,(function(e,s){e&&console.log(e)})),s}catch(e){return console.log("Error Sending otp "+e),0}}async function verifyOtp(e,s){try{const o=await Otp.findOne({user:e});return o?o.code!==s?0:1:0}catch(e){return console.error("Error:",e),0}}function generateRandomString(){let e="";for(let s=0;s<7;s++){const s=Math.floor(62*Math.random());e+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(s)}return e}function getlink(e){var s=e.indexOf("v=");if(-1!==s){s+=2;var o=e.indexOf("&",s);return-1!==o?e.substring(s,o):e.substring(s)}{const s=e.match(/youtu\.be\/(.*?)\?/);if(s){return s[1]}{const s=e.match(/live\/(.*?)\?/);return s?s[1]:null}}}mongoose.connect(mongoUrl,{useNewUrlParser:!0,useUnifiedTopology:!0}),mongoose.connection.on("connected",(()=>{console.log("DB connection successful")})),mongoose.connection.on("error",(e=>{console.log("DB connection failed",e)}));const wss=new WebSocket.Server({server:server}),roomDataMap=new Map,clientsMap=new Map;async function fetchAndSendUpdates(e,s){try{const o=await getfromdb(e,s),t=roomDataMap.get(e)||[];t.forEach((e=>{e.send(JSON.stringify(o))}))}catch(e){console.error("Error fetching and sending updates:",e)}}const connections=new Set;async function addservermessage(e,s){if(!(await User.find({email:e.user_id})).length>0)return null;const o=e,t=s,a=moment().tz("Asia/Karachi").format("YYYY-MM-DD HH:mm:ss");try{const e=await RoomModel.findOne({roomId:t});if(!e)throw console.error("Room not found"),new Error("Room not found");const s=o.user_id,n=e.coordinates.some((e=>e.email===s));var r=0;n?r=1:(e.coordinates.push({email:s,x:215,y:125}),await e.save());let i=await Message.findOne({room_id:t});if(i||(console.error("Room not found"),i=new Message({room_id:t,messages:[{user_id:o.user_id,content:o.content,time:a}]}),await i.save(),fetchAndSendUpdates(t)),i){i.messages=i.messages.filter((e=>"xxrp7"!==e.content));const e={user_id:o.user_id,content:o.content,time:a};if("xxrp7"==o.content)return fetchAndSendUpdates(t),null;if(i.messages.push(e),i.messages.length>60){const e=i.messages.length-60;i.messages.splice(0,e)}await i.save(),1==r?fetchAndSendUpdates(t,1):fetchAndSendUpdates(t)}}catch(e){console.error("Error:",e)}}async function getfromdb(e,o){if(1==o)try{const s=e;return{mess:(await Message.aggregate([{$match:{room_id:s}},{$project:{_id:0,room_id:1,messages:{$map:{input:"$messages",as:"message",in:{user_id:"$$message.user_id",content:"$$message.content",time:"$$message.time"}}}}}]))[0]}}catch(e){console.log("CANT FETCH MESSAGES "+e)}if(2==o)try{const o=(await RoomModel.aggregate([{$match:{roomId:e}},{$project:{_id:0,roomId:1,coordinates:{$map:{input:"$coordinates",as:"coord",in:{_id:"$$coord._id",email:"$$coord.email",x:"$$coord.x",y:"$$coord.y"}}}}}]))[0].coordinates;s=await Message.aggregate([{$match:{room_id:e}},{$project:{_id:0,room_id:1,messages:{$map:{input:"$messages",as:"message",in:{user_id:"$$message.user_id",content:"$$message.content",time:"$$message.time"}}}}}]);let t=[];s[0]&&(t=[...new Set(s[0].messages.map((e=>e.user_id)))]);return{coordinates:{coordinates:o,users:t}}}catch(e){console.log("Cannot fetch coordinates: "+e)}try{const s=e,o=await Message.aggregate([{$match:{room_id:s}},{$project:{_id:0,room_id:1,messages:{$map:{input:"$messages",as:"message",in:{user_id:"$$message.user_id",content:"$$message.content",time:"$$message.time"}}}}}]);let t=[];o[0]&&(t=[...new Set(o[0].messages.map((e=>e.user_id)))]);const a=await User.aggregate([{$match:{email:{$in:t}}},{$project:{_id:0,chatcolor:1,usernamecolor:1,username:1,password:1,email:1,badge:1,pic:1,backgroundPic:1,bio:1,likes:1,friends:1,premium:1}}]),r=await RoomModel.aggregate([{$match:{roomId:s}},{$project:{_id:0}}]),n=a.reduce(((e,s)=>{const{usernamecolor:o,chatcolor:t,username:a,password:r,email:n,badge:i,pic:c,backgroundPic:d,bio:m,likes:l,friends:u,premium:p}=s;return e[n]={chatcolor:t,usernamecolor:o,name:a,email:n,password:r,badge:i,pic:c,backgroundPic:d,bio:m,likes:l,friends:u,premium:p},e}),{}),i=(await RoomModel.aggregate([{$match:{roomId:e}},{$project:{_id:0,roomId:1,coordinates:{$map:{input:"$coordinates",as:"coord",in:{_id:"$$coord._id",email:"$$coord.email",x:"$$coord.x",y:"$$coord.y"}}}}}]))[0].coordinates;RoomModel.updateMany({},{$set:{users:t}}).then((e=>{})).catch((e=>{console.error("Error updating users:",e)})),RoomModel.updateMany({"coordinates.x":{$exists:!1},"coordinates.y":{$exists:!1}},{$set:{"coordinates.x":215,"coordinates.y":125}}).then((e=>{})).catch((e=>{console.error("Error updating coordinates:",e)}));const c=await Mods.aggregate([{$project:{_id:0}}]),d={...r[0],users:t,activemods:c},m={coordinates:i,users:t};return{mess:o[0],userdetails:n,roomdata:d,coordinates:m}}catch(e){throw console.error("Error in getfromdb:",e),e}}var roomids=[];async function updateCoordinatesWithRetry(e,s,o,t){const a=await RoomModel.findOne({roomId:e});if(!a)throw new Error("Room Not Found!");const r=a.coordinates.findIndex((e=>e.email===s));if(-1===r)throw new Error("User Not Found!");a.coordinates[r]?(a.coordinates[r].x=o,a.coordinates[r].y=t):a.coordinates[r]={email:s,x:o,y:t},await a.save(),fetchAndSendUpdates(e,2)}const activeUsers=new Map,inactivityTimeout=15e4;setInterval((()=>{const e=Date.now();activeUsers.forEach(((s,o)=>{e-s.lastActive>15e4&&activeUsers.delete(o)}))}),15e3),wss.on("connection",(e=>{connections.add(e),console.log("WebSocket client connected"),e.on("message",(async s=>{try{const o=JSON.parse(s);if("ping"==o.action){const s={msg:"pong"};e.send(JSON.stringify(s))}else if("getNotifications"===o.action){const{recipientEmail:s}=o.data;activeUsers.set(s,{connection:e,lastActive:Date.now()});try{const o=await Notification.find({recipient:s,read:!1}).populate("sender");e.send(JSON.stringify({notifications:o}));const t=Array.from(activeUsers.keys());e.send(JSON.stringify({onlineusers:t}))}catch(e){console.error("Error fetching notifications:",e)}}else if("text"===o.messageType)try{const{senderId:s,recipientId:t,messageType:a,message:r}=o,n=new PersonalMessage({senderId:s,recepientId:t,messageType:a,message:r,timestamp:new Date});await n.save(),wss.clients.forEach((s=>{s!==e&&s.readyState===WebSocket.OPEN&&s.send(JSON.stringify(n))}));const i=await PersonalMessage.countDocuments({senderId:s,recepientId:t});if(i>40){const e=await PersonalMessage.findOne({$or:[{senderId:s,recepientId:t},{senderId:t,recepientId:s}]},{},{sort:{timestamp:1}});e&&await PersonalMessage.deleteOne({_id:e._id})}else console.error("No messages found to remove.")}catch(e){console.error("Error saving chat message:",e)}else if("getMessages"===o.action){const{senderEmail:s,recipientEmail:t}=o.data,a=await PersonalMessage.find({$or:[{senderId:s,recepientId:t},{senderId:t,recepientId:s}]}).sort({timestamp:1});e.send(JSON.stringify(a))}else if("x"in o){const{roomId1:e,userId:s,x:t,y:a}=o;try{await updateCoordinatesWithRetry(e,s,t,a)}catch(e){console.error("Failed to update coordinates inside sockets",e)}}else if("roomId"in o){const s=o.roomId;roomMutex.runExclusive((async()=>{roomDataMap.has(s)||(roomDataMap.set(s,[]),roomids.push(s)),roomDataMap.get(s).push(e),roomids.push(s)})).then((()=>{const e=new Set(roomids),s=Array.from(e);roomids.length=0,roomids=[],s.forEach((e=>{fetchAndSendUpdates(e)}))}))}else"room_id"in o&&addservermessage(o.mymessage,o.room_id)}catch(e){console.error("Error parsing JSON:",e)}})),e.on("close",(()=>{roomDataMap.forEach(((s,o)=>{const t=s.indexOf(e);-1!==t&&s.splice(t,1)})),connections.delete(e),console.log("WebSocket client disconnected"),clientsMap.delete(e)}))})),app.use(userRoutes),app.get("/find-package",(async(e,s)=>{const o=e.query.email;try{const e=await ShopDetails.find({purchasedBy:o});if(e){const o=[];for(const s of e){const e=s.itemId,t=await PackageModel.findOne({id:e});t&&o.push({title:t.title,validtill:s.validtill})}o.length>0?s.json(o):s.status(404).json({message:"No matching packages found"})}else s.status(404).json({message:"ShopDetails not found"})}catch(e){s.status(500).json({error:"Internal server error"})}})),app.post("/unblockuser",(async(e,s)=>{const{roomIdx:o,userIdx:t}=e.body;try{const e=await RoomModel.findOne({roomId:o});if(!e)return s.status(404).json({message:"Room not found"});const a=e.blocked.indexOf(t);return-1!==a?(e.blocked.splice(a,1),await e.save(),fetchAndSendUpdates(o),s.sendStatus(200)):s.sendStatus(404)}catch(e){return console.error(e),s.sendStatus(500)}})),app.post("/verotp",(async(e,s)=>{try{await verifyOtp(e.body.email,e.body.otp)?s.sendStatus(200):s.sendStatus(203)}catch(e){return console.log(e),s.status(500)}})),app.post("/buyitem",(async(e,s)=>{const o=await mongoose.startSession();o.startTransaction();try{const a=moment().tz("Asia/Karachi").format("YYYY-MM-DD HH:mm:ss"),{itemid:r,userid:n,type:i,price:c,duration:d}=e.body,m=await User.findOne({email:n}).session(o);if(!m)throw new Error("User not found");if(c<=m.balance){const e=await PackageModel.findOne({id:r}).session(o);if(!e)throw new Error("Shop item not found");"badge"===i?m.badge=e.id:"chatcolor"===i?m.chatcolor=e.id:"namecolor"===i?m.namecolor=e.id:("vip2"===i||"vip3"===i)&&(m.premium=e.type),m.balance-=c,await m.save();var t={};if("1 Month"==d){const e=moment(a,"YYYY-MM-DD HH:mm:ss").add(30,"days");t={itemId:r,purchasedBy:n,purchaseDate:a,validtill:e.format("YYYY-MM-DD HH:mm:ss")}}if("3 Months"==d){const e=moment(a,"YYYY-MM-DD HH:mm:ss").add(90,"days");t={itemId:r,purchasedBy:n,purchaseDate:a,validtill:e.format("YYYY-MM-DD HH:mm:ss")}}if("6 Months"==d){const e=moment(a,"YYYY-MM-DD HH:mm:ss").add(180,"days");t={itemId:r,purchasedBy:n,purchaseDate:a,validtill:e.format("YYYY-MM-DD HH:mm:ss")}}if("1 Year"==d){const e=moment(a,"YYYY-MM-DD HH:mm:ss").add(364,"days");t={itemId:r,purchasedBy:n,purchaseDate:a,validtill:e.format("YYYY-MM-DD HH:mm:ss")}}const l=new ShopDetails(t);await l.save();const u=await mergedates(n,r);0!=u?(s.status(200).json({date:u}),await o.commitTransaction(),o.endSession()):(s.sendStatus(202),await o.commitTransaction(),o.endSession())}else s.sendStatus(202),await o.commitTransaction(),o.endSession()}catch(e){await o.abortTransaction(),o.endSession(),console.error(e),s.sendStatus(400)}})),app.get("/api/packages",(async(e,s)=>{try{const e=await PackageModel.find();s.json(e)}catch(e){console.error("Error fetching packages:",e),s.status(500).json({error:"An error occurred while fetching packages"})}})),app.post("/sendotp",(async(e,s)=>{try{var o=sendotp(e.body.email,genotp());0!=o&&s.json({otp:o})}catch(e){return console.log(e),s.status(500)}})),app.post("/resetpassword",(async(e,s)=>{try{const{email:o,password:t}=e.body,a=await bcrypt.hash(t,10),r=await User.findOne({email:o});if(!r)throw s.sendStatus(202),new Error("User not found");r.password=a,await r.save(),s.sendStatus(200)}catch(e){return console.log(e),s.status(500)}})),app.post("/storesms",(async(e,s)=>{const o=moment().tz("Asia/Karachi").format("YYYY-MM-DD HH:mm:ss");for(var t=0;t<e.body.length;t++){var a=e.body[t],r=a["Trx ID"];const s={transaction_id:r=r.replace("Trx ID ",""),amount:a.Amount,time:o};new TransactionModel(s).save().catch((e=>{e.message.includes("duplicate key")}))}s.sendStatus(200)})),app.get("/find-transaction/:transaction_id",(async(e,s)=>{const o=await mongoose.startSession();o.startTransaction();try{const t=e.params.transaction_id,a=e.query.userEmail,r=await TransactionModel.findOne({transaction_id:t}).session(o);if(!r)return await o.abortTransaction(),o.endSession(),s.status(404).json({message:"Transaction not found"});if("verified"===r.status){r.status="done",r.email=a;const e=await User.findOne({email:a}).session(o);return e?(e.balance+=parseFloat(r.amount),await Promise.all([e.save({session:o}),r.save({session:o})]),await o.commitTransaction(),o.endSession(),s.status(200).json({amount:e.balance})):(await o.abortTransaction(),o.endSession(),s.status(404).json({message:"User not found"}))}return await o.abortTransaction(),o.endSession(),s.status(403).json({message:"Transaction is not verified"})}catch(e){return console.error(e),await o.abortTransaction(),o.endSession(),s.status(500).json({message:"Internal server error"})}})),app.get("/api/payment-details",(async(e,s)=>{try{const e=await PaymentDetailsModel.findOne({});if(!e)return s.status(404).json({error:"Payment details not found"});s.json(e)}catch(e){return s.status(500).json({error:"Internal Server Error"})}})),app.get("/find-transactions/:email",(async(e,s)=>{try{const o=e.params.email,t=await TransactionModel.find({email:o,status:"done"});if(0===t.length)return s.status(404).json({message:'No transactions found with status "done" for the specified email.'});s.status(200).json(t)}catch(e){console.error(e),s.status(500).json({message:"Internal server error"})}})),app.get("/fetchver",(async(e,s)=>{try{t={version:"1.1.0",link:"https://shorturl.at/pBDEP"},s.json(t)}catch(e){console.error("Error:",e),s.status(500).json({error:"Internal server error"})}})),app.get("/fetchData",(async(e,s)=>{try{const e=await RoomModel.find(),o=await Offer.aggregate([{$project:{_id:0,__v:0}}]),t=await Mods.aggregate([{$project:{_id:0,__v:0}}]),a=await Banned.aggregate([{$project:{_id:0,__v:0}}]),r={documents:e,offer:o[0],mymods:t,banned:a};s.json(r)}catch(e){console.error("Error:",e),s.status(500).json({error:"Internal server error"})}})),app.post("/fetchcolors",(async(e,s)=>{const{userid:o}=e.body.a;try{const e=await User.find({email:o},{_id:0,chatcolor:1,premium:1}),t={allcolors:await ColorsModel.aggregate([{$project:{_id:0,__v:0}}]),premium:e[0]};s.status(200).json(t)}catch(e){console.log(e),s.status(500).json({error:"Internal Server Error"})}})),app.post("/updatebackgroundpic",(async(e,s)=>{const o=await mongoose.startSession();o.startTransaction();try{const{useremail:t,profileurl:a}=e.body.imgdata,r=await User.findOneAndUpdate({email:t},{backgroundPic:a},{new:!0}).session(o);await o.commitTransaction(),o.endSession(),s.json({message:"Profile Pic updated successfully",user:r})}catch(e){await o.abortTransaction(),o.endSession(),console.error(e),s.status(500).json({message:"An error occurred"})}})),app.get("/users/:email/profile",(async(e,s)=>{try{const o=e.params.email,t=await User.findOne({email:o});if(!t)return s.status(404).json({message:"User not found"});s.status(200).json(t)}catch(e){console.error(e),s.status(500).json({message:"Server error"})}app.put("/users/:email/updateprofile",(async(e,s)=>{try{const o=e.params.email,{username:t,bio:a}=e.body,r=await User.findOne({email:o});if(!r)return s.status(404).json({message:"User not found"});r.username=t,r.bio=a,await r.save(),s.status(200).json({message:"User updated successfully"})}catch(e){console.error(e),s.status(500).json({message:"Server error"})}}))})),app.post("/users/:userId/increment-likes",(async(e,s)=>{const{userId:o}=e.params,{user:t}=e.body;try{const e=await User.findOne({email:o});return e?e.likedBy.includes(t)?s.status(400).json({message:"You have already liked this profile"}):(e.likes+=1,e.likedBy.push(t),await e.save(),s.status(200).json({user:e})):s.status(404).json({message:"User not found"})}catch(e){return console.error(e),s.status(500).json({message:"Internal server error"})}})),app.post("/warning-notifications",(async(e,s)=>{try{const{sender:o,recipients:t,message:a,type:r,pic:n}=e.body,i=t.map((async e=>{if(null===e||""==e);else try{const s=new Notification({sender:o,recipient:e,message:a,type:r,pic:n});return await s.save(),s}catch(e){}}));await Promise.all(i),s.status(201).json({message:"Notifications created"})}catch(e){console.error(e),s.status(500).json({message:"Internal server error"})}})),app.post("/notifications",(async(e,s)=>{try{const{sender:o,recipient:t,message:a,type:r}=e.body;if("friendRequest"===r){const e=await User.findOne({email:t});if(e&&e.friends.some((e=>e.email===o)))return s.status(200).json({message:"You are already friends with this user"});{if(await Notification.findOne({sender:o,recipient:t,type:"friendRequest",read:!1}))return s.status(202).json({message:"Friend request already sent"});const e=await User.findOne({email:o}),n=new Notification({sender:o,recipient:t,message:`${e.username} ${a}`,type:r,pic:e.pic});await n.save(),s.status(201).json({message:"Notification created"})}}if("profileLike"===r){await User.findOne({email:t});const e=await User.findOne({email:o}),n=new Notification({sender:o,recipient:t,message:`${e.username} ${a}`,type:r,pic:e.pic});await n.save(),s.status(201).json({message:"Notification created"})}}catch(e){console.error(e),s.status(500).json({message:"Internal server error"})}})),app.post("/addfriend",(async(e,s)=>{const{username:o,useremail:t,friendUsername:a,friendEmail:r}=e.body;try{const e=await User.findOne({email:t});if(!e)return s.status(404).json({error:"Sender not found"});const n=await User.findOne({email:r});if(!n)return s.status(404).json({error:"Receiver not found"});const i={username:a,email:r},c={username:o,email:e.email};e.friends.push(i),n.friends.push(c),await e.save(),await n.save(),s.status(200).json({message:"Friend added successfully"})}catch(e){console.error(e),s.status(500).json({error:"Internal server error"})}})),app.put("/updateposition",(async(e,s)=>{try{const{roomId1:o,userId:t,x:a,y:r}=e.body,n=await RoomModel.findOne({roomId:o});if(!n)return s.status(404).json({error:"Room not found"});const i=n.users.findIndex((e=>e===t));if(-1===i)return s.status(404).json({error:"User not found in the room"});n.coordinates[i]?(n.coordinates[i].x=a,n.coordinates[i].y=r):n.coordinates[i]={email:t,x:a,y:r},await n.save(),s.status(200).json({message:"User position updated successfully"})}catch(e){console.error(e),s.status(500).json({error:"Internal server error"})}})),app.get("/getusercoordinates",(async(e,s)=>{try{const{roomId:o,userEmails:t}=e.query;if(!Array.isArray(t))return s.status(400).json({error:"Invalid userEmails parameter"});const a=await RoomModel.findOne({roomId:o});if(!a)return s.status(404).json({error:"Room not found"});const r=a.coordinates.filter((e=>t.includes(e.email))).map((e=>({x:e.x,y:e.y,email:e.email})));if(0===r.length)return s.status(404).json({error:"No matching users found in the room"});s.status(200).json(r)}catch(e){console.error(e),s.status(500).json({error:"Internal server error"})}})),app.put("/notifications/:notificationId/mark-as-read",(async(e,s)=>{const{notificationId:o}=e.params;try{const e=await Notification.findByIdAndUpdate(o,{read:!0},{new:!0});if(!e)return s.status(404).json({error:"Notification not found"});s.status(200).json({message:"Notification marked as read",notification:e})}catch(e){console.error("Error marking notification as read:",e),s.status(500).json({error:"Internal server error"})}})),app.get("/users/:userId/friends",(async(e,s)=>{try{const o=e.params.userId,t=await User.findOne({email:o});if(!t)return s.status(404).json({message:"User not found"});const a=t.friends.map((e=>e.email)),r=await User.find({email:{$in:a}});s.json({friends:r})}catch(e){console.error("Error fetching user friends:",e),s.status(500).json({message:"Internal server error"})}})),app.post("/changecolor",(async(e,s)=>{const{user:o,hex:t}=e.body.det;try{return await User.findOneAndUpdate({email:o},{chatcolor:t},{new:!0})?s.status(200).json({message:"Color updated successfully"}):s.status(404).json({error:"User not found"})}catch(e){return console.error("Error updating color: "+e),s.status(500).json({error:"An error occurred while updating the color"})}})),app.post("/changeusernamecolor",(async(e,s)=>{const{user:o,hex:t}=e.body.det;try{return await User.findOneAndUpdate({email:o},{usernamecolor:t},{new:!0})?s.sendStatus(200):s.sendStatus(404)}catch(e){return console.error("Error updating color: "+e),s.status(500).json({error:"An error occurred while updating the color"})}})),app.post("/muteuser",(async(e,s)=>{const{u:o,t:t,roomid:a}=e.body.mutedata;try{const e=await RoomModel.find({});if(e&&e.length>0){for(const s of e)s.muted.push(o),s.muted.push(t),s.save(),fetchAndSendUpdates(s.roomId);s.status(200).send("User muted in all rooms!")}else s.status(404).send("No rooms found")}catch(e){console.log("Error muting: "+e),s.status(500).send("Error muting: "+e)}})),app.post("/blockuser",(async(e,s)=>{const{u:o,rx:t}=e.body.blockdata;try{const e=await mongoose.startSession();e.startTransaction();const a=await RoomModel.findOne({roomId:t});a&&(a.blocked.push(o),await a.save({session:e})),await e.commitTransaction(),e.endSession(),fetchAndSendUpdates(t),s.status(200).json({message:"User Blocked Successfully!"})}catch(e){console.error("Error Blocking User: "+e),s.status(500).json({error:"An error occurred while blocking the user."})}})),app.post("/createroom",(async(e,s)=>{const{name:o,pic:t,bio:a,videoUrl:r,usern:n}=e.body.roombody;var i=getlink(r);i=null==i||""==i?"":"https://www.youtube.com/embed/"+i;try{const e=await mongoose.startSession();e.startTransaction();const r={email:n,x:215,y:125},c=generateRandomString(),d={roomId:c,name:o,coordinates:r,badgeurl:t,videourl:i,bio:a,mods:[n]},m=await RoomModel(d);await m.save({session:e});const l=moment().tz("Asia/Karachi").format("YYYY-MM-DD HH:mm:ss"),u=new Message({room_id:c,messages:[{user_id:n,content:"xxrp7",time:l},{user_id:n,content:"xxrp7",time:l},{user_id:n,content:"xxrp7",time:l}]});await u.save({session:e}),await e.commitTransaction(),e.endSession(),s.json({stat:200})}catch(e){console.log("Error Creating Room :  "+e)}})),app.post("/updatebadge",(async(e,s)=>{const o=await mongoose.startSession();o.startTransaction();try{const{email:t,badgeUrl:a}=e.body.badgedata,r=await User.findOneAndUpdate({email:t},{badge:a},{new:!0}).session(o);await o.commitTransaction(),o.endSession(),s.json({message:"Badge updated successfully",user:r})}catch(e){await o.abortTransaction(),o.endSession(),console.error(e),s.status(500).json({message:"An error occurred"})}})),app.get("/notifications/:userId",(async(e,s)=>{try{const{userId:o}=e.params,t=await Notification.find({recipient:o,read:!1}).populate("sender");s.status(200).json({notifications:t})}catch(e){console.error(e),s.status(500).json({message:"Internal server error"})}})),app.post("/updateprofilepic",(async(e,s)=>{const o=await mongoose.startSession();o.startTransaction();try{const{useremail:t,profileurl:a}=e.body.imgdata,r=await User.findOneAndUpdate({email:t},{pic:a},{new:!0}).session(o);await o.commitTransaction(),o.endSession(),s.json({message:"Profile Pic updated successfully",user:r})}catch(e){await o.abortTransaction(),o.endSession(),console.error(e),s.status(500).json({message:"An error occurred"})}})),app.post("/loadbages",(async(e,s)=>{const o=await mongoose.startSession();o.startTransaction();try{const e=await badgeModel.aggregate([{$match:{badgeid:"123"}},{$project:{_id:0}}]).session(o);await o.commitTransaction(),o.endSession(),s.json(e[0])}catch(e){await o.abortTransaction(),o.endSession(),console.error(e),s.status(500).json({message:"An error occurred"})}})),app.post("/updateroom",(async(e,s)=>{const o=await mongoose.startSession();try{await o.withTransaction((async()=>{const{roomid:t,pic:a,name:r,bio:n,videoUrl:i}=e.body.roombody;var d=i;if(i.includes("embed")||(d=null==d||""==d||d.length<=6?"":"https://www.youtube.com/embed/"+(d=getlink(i))),c={},a&&(c.badgeurl=a),r&&(c.name=r),n&&(c.bio=n),i&&(c.videourl=d),!await RoomModel.findOneAndUpdate({roomId:t},{$set:c},{new:!0,session:o}))throw new Error("Room not found");s.json({stat:200})}))}catch(e){}finally{o.endSession()}})),app.post("/deleteroom",(async(e,s)=>{const{roomid:o}=e.body;try{if(!await RoomModel.findOneAndDelete({roomId:o}))return s.status(404).json({error:"Room not found"});s.json({s:200})}catch(e){console.log("Room Deletion Failed: "+e),s.status(500).json({error:"Room Deletion Failed"})}})),app.post("/removeprofilepic",(async(e,s)=>{const o=await mongoose.startSession();o.startTransaction();try{const{user:t}=e.body.a;await User.findOneAndUpdate({email:t},{pic:"https://cdn-icons-png.flaticon.com/512/3177/3177440.png"},{new:!0}).session(o);await o.commitTransaction(),o.endSession(),s.sendStatus(200)}catch(e){await o.abortTransaction(),o.endSession(),console.error(e),s.status(500).json({message:"An error occurred"})}})),app.post("/removebackpic",(async(e,s)=>{const o=await mongoose.startSession();o.startTransaction();try{const{user:t}=e.body.a;await User.findOneAndUpdate({email:t},{backgroundPic:"https://as2.ftcdn.net/v2/jpg/01/68/74/87/1000_F_168748763_Mdv7zO7dxuECMzItERhPzWhVJSaORTKd.jpg"},{new:!0}).session(o);await o.commitTransaction(),o.endSession(),s.sendStatus(200)}catch(e){await o.abortTransaction(),o.endSession(),console.error(e),s.status(500).json({message:"An error occurred"})}})),app.post("/removebio",(async(e,s)=>{const o=await mongoose.startSession();o.startTransaction();try{const{user:t}=e.body.a;await User.findOneAndUpdate({email:t},{bio:"Hi i am ChatZyr User!"},{new:!0}).session(o);await o.commitTransaction(),o.endSession(),s.sendStatus(200)}catch(e){await o.abortTransaction(),o.endSession(),console.error(e),s.status(500).json({message:"An error occurred"})}})),app.delete("/deleteAccount/:email",(async(e,s)=>{const{email:o}=e.params,t=await mongoose.startSession();t.startTransaction();try{await User.findOneAndDelete({email:o}).session(t),await Notification.deleteMany({$or:[{sender:o},{recipient:o}]}).session(t);const e=await Mods.findOne({$or:[{mod1:o},{mod2:o}]});e&&(e.mod1.includes(o)?e.mod1=e.mod1.filter((e=>e!==o)):e.mod2=e.mod2.filter((e=>e!==o)),await e.save());await deleteMessages(o);deleteCoordinates(o),await t.commitTransaction(),t.endSession(),s.status(200).json({message:"User account and associated data deleted successfully."})}catch(e){await t.abortTransaction(),t.endSession(),console.error(e),s.status(500).json({error:"An error occurred while deleting the user account."})}})),app.get("/search",(async(e,s)=>{const{query:o}=e.query;try{const e=await User.find({username:{$regex:o,$options:"i"}});s.json(e)}catch(e){console.error(e),s.status(500).json({error:"Internal server error"})}})),app.get("/user",(async(e,s)=>{try{const o=e.query.email;if(!o)return s.status(400).json({message:"Email is required"});const t=await User.findOne({email:o});if(!t)return s.status(404).json({message:"User not found"});s.status(200).json(t)}catch(e){console.error(e),s.status(500).json({message:"Server error"})}})),server.listen(PORT,(()=>{console.log("Sockets Server listening on port "+PORT)}));
